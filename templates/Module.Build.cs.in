using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using UnrealBuildTool;

public class ${ModuleName} : ModuleRules
{ 
    private static Dictionary<string, object> GetMatchingFileRecord(UnrealArch arch, UnrealTargetPlatform platform, IEnumerable<Dictionary<string, object>> fileRecords)
    {
        foreach (Dictionary<string, object> record in fileRecords)
        {
            UnrealArch matchingArch = UnrealArch.Parse((string)record["MatchingArchitecture"]);
            UnrealTargetPlatform matchingPlatform = UnrealTargetPlatform.Parse((string)record["MatchingTargetPlatform"]);
            if (matchingArch == arch && matchingPlatform == platform)
            {
                return record;
            }
        }

        return null;
    }

    public ${ModuleName}(ReadOnlyTargetRules Target) : base(Target)
    {
        Type = ModuleType.External;

        Dictionary<string, object>[] records = ${TripletFileRecords};
		string[] dependencyModuleNames = new string[]{${DependencyModuleNames}};
		string[] dependencyModuleLoaderNames = new string[]{${DependencyModuleLoaderNames}};

        Dictionary<string, object> tripletFileRecord = GetMatchingFileRecord(Target.Architecture, Target.Platform, records);
        if (tripletFileRecord == null)
        {
            throw new Exception($"Platform and Architecture combination is not supported: {Target.Platform.ToString()}|{Target.Architecture.ToString()}");
        }

        PublicDefinitions.AddRange((string[])tripletFileRecord["PublicDefinitions"]);
        PublicSystemIncludePaths.AddRange((string[])tripletFileRecord["PublicIncludePaths"]);
        PublicAdditionalLibraries.AddRange((string[])tripletFileRecord["PublicAdditionalLibraries"]);
        foreach (string dll in (string[])tripletFileRecord["RuntimeDependencies"])
        {
            RuntimeDependencies.Add(dll);
        }
		
		PublicDependencyModuleNames.AddRange(dependencyModuleNames);

        if (Target.Type == TargetType.Editor)
        {
            foreach (string dynamicLib in (string[])tripletFileRecord["RuntimeDependencies"])
            {
                string dynamicLibFileName = Path.GetFileName(dynamicLib);
                PublicDelayLoadDLLs.Add(dynamicLibFileName);
            }
			
			foreach(string dependencyModuleLoaderName in dependencyModuleLoaderNames)
			{
				PrivateDependencyModuleNames.Add(dependencyModuleLoaderName);
			}
        }
    }
}